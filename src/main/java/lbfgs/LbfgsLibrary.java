package lbfgs;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.Structure;
import com.sun.jna.ptr.DoubleByReference;
import java.nio.DoubleBuffer;
import java.util.Arrays;
import java.util.List;
/**
 * JNA Wrapper for library <b>lbfgs</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface LbfgsLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "lbfgs";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(LbfgsLibrary.JNA_LIBRARY_NAME);
	public static final LbfgsLibrary INSTANCE = (LbfgsLibrary)Native.loadLibrary(LbfgsLibrary.JNA_LIBRARY_NAME, LbfgsLibrary.class);
	/** L-BFGS reaches convergence. */
	public static final int LBFGS_SUCCESS = 0;
	public static final int LBFGS_CONVERGENCE = 0;
	public static final int LBFGS_STOP = 1;
	/** The initial variables already minimize the objective function. */
	public static final int LBFGS_ALREADY_MINIMIZED = 2;
	/** Unknown error. */
	public static final int LBFGSERR_UNKNOWNERROR = -1024;
	/** Logic error. */
	public static final int LBFGSERR_LOGICERROR = -1023;
	/** Insufficient memory. */
	public static final int LBFGSERR_OUTOFMEMORY = -1022;
	/** The minimization process has been canceled. */
	public static final int LBFGSERR_CANCELED = -1021;
	/** Invalid number of variables specified. */
	public static final int LBFGSERR_INVALID_N = -1020;
	/** Invalid number of variables (for SSE) specified. */
	public static final int LBFGSERR_INVALID_N_SSE = -1019;
	/** The array x must be aligned to 16 (for SSE). */
	public static final int LBFGSERR_INVALID_X_SSE = -1018;
	/** Invalid parameter lbfgs_parameter_t::epsilon specified. */
	public static final int LBFGSERR_INVALID_EPSILON = -1017;
	/** Invalid parameter lbfgs_parameter_t::past specified. */
	public static final int LBFGSERR_INVALID_TESTPERIOD = -1016;
	/** Invalid parameter lbfgs_parameter_t::delta specified. */
	public static final int LBFGSERR_INVALID_DELTA = -1015;
	/** Invalid parameter lbfgs_parameter_t::linesearch specified. */
	public static final int LBFGSERR_INVALID_LINESEARCH = -1014;
	/** Invalid parameter lbfgs_parameter_t::max_step specified. */
	public static final int LBFGSERR_INVALID_MINSTEP = -1013;
	/** Invalid parameter lbfgs_parameter_t::max_step specified. */
	public static final int LBFGSERR_INVALID_MAXSTEP = -1012;
	/** Invalid parameter lbfgs_parameter_t::ftol specified. */
	public static final int LBFGSERR_INVALID_FTOL = -1011;
	/** Invalid parameter lbfgs_parameter_t::wolfe specified. */
	public static final int LBFGSERR_INVALID_WOLFE = -1010;
	/** Invalid parameter lbfgs_parameter_t::gtol specified. */
	public static final int LBFGSERR_INVALID_GTOL = -1009;
	/** Invalid parameter lbfgs_parameter_t::xtol specified. */
	public static final int LBFGSERR_INVALID_XTOL = -1008;
	/** Invalid parameter lbfgs_parameter_t::max_linesearch specified. */
	public static final int LBFGSERR_INVALID_MAXLINESEARCH = -1007;
	/** Invalid parameter lbfgs_parameter_t::orthantwise_c specified. */
	public static final int LBFGSERR_INVALID_ORTHANTWISE = -1006;
	/** Invalid parameter lbfgs_parameter_t::orthantwise_start specified. */
	public static final int LBFGSERR_INVALID_ORTHANTWISE_START = -1005;
	/** Invalid parameter lbfgs_parameter_t::orthantwise_end specified. */
	public static final int LBFGSERR_INVALID_ORTHANTWISE_END = -1004;
	/** The line-search step went out of the interval of uncertainty. */
	public static final int LBFGSERR_OUTOFINTERVAL = -1003;
	/**
	 * A logic error occurred; alternatively, the interval of uncertainty<br>
	 * became too small.
	 */
	public static final int LBFGSERR_INCORRECT_TMINMAX = -1002;
	/**
	 * A rounding error occurred; alternatively, no line-search step<br>
	 * satisfies the sufficient decrease and curvature conditions.
	 */
	public static final int LBFGSERR_ROUNDING_ERROR = -1001;
	/** The line-search step became smaller than lbfgs_parameter_t::min_step. */
	public static final int LBFGSERR_MINIMUMSTEP = -1000;
	/** The line-search step became larger than lbfgs_parameter_t::max_step. */
	public static final int LBFGSERR_MAXIMUMSTEP = -999;
	/** The line-search routine reaches the maximum number of evaluations. */
	public static final int LBFGSERR_MAXIMUMLINESEARCH = -998;
	/** The algorithm routine reaches the maximum number of iterations. */
	public static final int LBFGSERR_MAXIMUMITERATION = -997;
	/**
	 * Relative width of the interval of uncertainty is at most<br>
	 * lbfgs_parameter_t::xtol.
	 */
	public static final int LBFGSERR_WIDTHTOOSMALL = -996;
	/** A logic error (negative line-search step) occurred. */
	public static final int LBFGSERR_INVALIDPARAMETERS = -995;
	/** The current search direction increases the objective function value. */
	public static final int LBFGSERR_INCREASEGRADIENT = -994;
	/** The default algorithm (MoreThuente method). */
	public static final int LBFGS_LINESEARCH_DEFAULT = 0;
	/** MoreThuente method proposd by More and Thuente. */
	public static final int LBFGS_LINESEARCH_MORETHUENTE = 0;
	/**
	 * Backtracking method with the Armijo condition.<br>
	 *  The backtracking method finds the step length such that it satisfies<br>
	 *  the sufficient decrease (Armijo) condition,<br>
	 *    - f(x + a * d) <= f(x) + lbfgs_parameter_t::ftol * a * g(x)^T d,<br>
	 * *  where x is the current point, d is the current search direction, and<br>
	 *  a is the step length.
	 */
	public static final int LBFGS_LINESEARCH_BACKTRACKING_ARMIJO = 1;
	/** The backtracking method with the defualt (regular Wolfe) condition. */
	public static final int LBFGS_LINESEARCH_BACKTRACKING = 2;
	/**
	 * Backtracking method with regular Wolfe condition.<br>
	 *  The backtracking method finds the step length such that it satisfies<br>
	 *  both the Armijo condition (LBFGS_LINESEARCH_BACKTRACKING_ARMIJO)<br>
	 *  and the curvature condition,<br>
	 *    - g(x + a * d)^T d >= lbfgs_parameter_t::wolfe * g(x)^T d,<br>
	 * *  where x is the current point, d is the current search direction, and<br>
	 *  a is the step length.
	 */
	public static final int LBFGS_LINESEARCH_BACKTRACKING_WOLFE = 2;
	/**
	 * Backtracking method with strong Wolfe condition.<br>
	 *  The backtracking method finds the step length such that it satisfies<br>
	 *  both the Armijo condition (LBFGS_LINESEARCH_BACKTRACKING_ARMIJO)<br>
	 *  and the following condition,<br>
	 *    - |g(x + a * d)^T d| <= lbfgs_parameter_t::wolfe * |g(x)^T d|,<br>
	 * *  where x is the current point, d is the current search direction, and<br>
	 *  a is the step length.
	 */
	public static final int LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE = 3;
	public static final int LBFGS_FLOAT = (int)64;
	public static final int LBFGS_IEEE_FLOAT = (int)1;
	public static class lbfgs_parameter_t extends Structure {
		/**
		 * The number of corrections to approximate the inverse hessian matrix.<br>
		 *  The L-BFGS routine stores the computation results of previous \ref m<br>
		 *  iterations to approximate the inverse hessian matrix of the current<br>
		 *  iteration. This parameter controls the size of the limited memories<br>
		 *  (corrections). The default value is \c 6. Values less than \c 3 are<br>
		 *  not recommended. Large values will result in excessive computing time.
		 */
		public int m;
		/**
		 * Epsilon for convergence test.<br>
		 *  This parameter determines the accuracy with which the solution is to<br>
		 *  be found. A minimization terminates when<br>
		 *      ||g|| < \ref epsilon * max(1, ||x||),<br>
		 *  where ||.|| denotes the Euclidean (L2) norm. The default value is<br>
		 *  \c 1e-5.<br>
		 * C type : lbfgsfloatval_t
		 */
		public double epsilon;
		/**
		 * Distance for delta-based convergence test.<br>
		 *  This parameter determines the distance, in iterations, to compute<br>
		 *  the rate of decrease of the objective function. If the value of this<br>
		 *  parameter is zero, the library does not perform the delta-based<br>
		 *  convergence test. The default value is \c 0.
		 */
		public int past;
		/**
		 * Delta for convergence test.<br>
		 *  This parameter determines the minimum rate of decrease of the<br>
		 *  objective function. The library stops iterations when the<br>
		 *  following condition is met:<br>
		 *      (f' - f) / f < \ref delta,<br>
		 *  where f' is the objective value of \ref past iterations ago, and f is<br>
		 *  the objective value of the current iteration.<br>
		 *  The default value is \c 0.<br>
		 * C type : lbfgsfloatval_t
		 */
		public double delta;
		/**
		 * The maximum number of iterations.<br>
		 *  The lbfgs() function terminates an optimization process with<br>
		 *  ::LBFGSERR_MAXIMUMITERATION status code when the iteration count<br>
		 *  exceedes this parameter. Setting this parameter to zero continues an<br>
		 *  optimization process until a convergence or error. The default value<br>
		 *  is \c 0.
		 */
		public int max_iterations;
		/**
		 * The line search algorithm.<br>
		 *  This parameter specifies a line search algorithm to be used by the<br>
		 *  L-BFGS routine.
		 */
		public int linesearch;
		/**
		 * The maximum number of trials for the line search.<br>
		 *  This parameter controls the number of function and gradients evaluations<br>
		 *  per iteration for the line search routine. The default value is \c 20.
		 */
		public int max_linesearch;
		/**
		 * The minimum step of the line search routine.<br>
		 *  The default value is \c 1e-20. This value need not be modified unless<br>
		 *  the exponents are too large for the machine being used, or unless the<br>
		 *  problem is extremely badly scaled (in which case the exponents should<br>
		 *  be increased).<br>
		 * C type : lbfgsfloatval_t
		 */
		public double min_step;
		/**
		 * The maximum step of the line search.<br>
		 *  The default value is \c 1e+20. This value need not be modified unless<br>
		 *  the exponents are too large for the machine being used, or unless the<br>
		 *  problem is extremely badly scaled (in which case the exponents should<br>
		 *  be increased).<br>
		 * C type : lbfgsfloatval_t
		 */
		public double max_step;
		/**
		 * A parameter to control the accuracy of the line search routine.<br>
		 *  The default value is \c 1e-4. This parameter should be greater<br>
		 *  than zero and smaller than \c 0.5.<br>
		 * C type : lbfgsfloatval_t
		 */
		public double ftol;
		/**
		 * A coefficient for the Wolfe condition.<br>
		 *  This parameter is valid only when the backtracking line-search<br>
		 *  algorithm is used with the Wolfe condition,<br>
		 *  ::LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE or<br>
		 *  ::LBFGS_LINESEARCH_BACKTRACKING_WOLFE .<br>
		 *  The default value is \c 0.9. This parameter should be greater<br>
		 *  the \ref ftol parameter and smaller than \c 1.0.<br>
		 * C type : lbfgsfloatval_t
		 */
		public double wolfe;
		/**
		 * A parameter to control the accuracy of the line search routine.<br>
		 *  The default value is \c 0.9. If the function and gradient<br>
		 *  evaluations are inexpensive with respect to the cost of the<br>
		 *  iteration (which is sometimes the case when solving very large<br>
		 *  problems) it may be advantageous to set this parameter to a small<br>
		 *  value. A typical small value is \c 0.1. This parameter shuold be<br>
		 *  greater than the \ref ftol parameter (\c 1e-4) and smaller than<br>
		 *  \c 1.0.<br>
		 * C type : lbfgsfloatval_t
		 */
		public double gtol;
		/**
		 * The machine precision for floating-point values.<br>
		 *  This parameter must be a positive value set by a client program to<br>
		 *  estimate the machine precision. The line search routine will terminate<br>
		 *  with the status code (::LBFGSERR_ROUNDING_ERROR) if the relative width<br>
		 *  of the interval of uncertainty is less than this parameter.<br>
		 * C type : lbfgsfloatval_t
		 */
		public double xtol;
		/**
		 * Coeefficient for the L1 norm of variables.<br>
		 *  This parameter should be set to zero for standard minimization<br>
		 *  problems. Setting this parameter to a positive value activates<br>
		 *  Orthant-Wise Limited-memory Quasi-Newton (OWL-QN) method, which<br>
		 *  minimizes the objective function F(x) combined with the L1 norm |x|<br>
		 *  of the variables, {F(x) + C |x|}. This parameter is the coeefficient<br>
		 *  for the |x|, i.e., C. As the L1 norm |x| is not differentiable at<br>
		 *  zero, the library modifies function and gradient evaluations from<br>
		 *  a client program suitably; a client program thus have only to return<br>
		 *  the function value F(x) and gradients G(x) as usual. The default value<br>
		 *  is zero.<br>
		 * C type : lbfgsfloatval_t
		 */
		public double orthantwise_c;
		/**
		 * Start index for computing L1 norm of the variables.<br>
		 *  This parameter is valid only for OWL-QN method<br>
		 *  (i.e., \ref orthantwise_c != 0). This parameter b (0 <= b < N)<br>
		 *  specifies the index number from which the library computes the<br>
		 *  L1 norm of the variables x,<br>
		 *      |x| := |x_{b}| + |x_{b+1}| + ... + |x_{N}| .<br>
		 *  In other words, variables x_1, ..., x_{b-1} are not used for<br>
		 *  computing the L1 norm. Setting b (0 < b < N), one can protect<br>
		 *  variables, x_1, ..., x_{b-1} (e.g., a bias term of logistic<br>
		 *  regression) from being regularized. The default value is zero.
		 */
		public int orthantwise_start;
		/**
		 * End index for computing L1 norm of the variables.<br>
		 *  This parameter is valid only for OWL-QN method<br>
		 *  (i.e., \ref orthantwise_c != 0). This parameter e (0 < e <= N)<br>
		 *  specifies the index number at which the library stops computing the<br>
		 *  L1 norm of the variables x,
		 */
		public int orthantwise_end;
		
		
		public lbfgs_parameter_t() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("m", "epsilon", "past", "delta", "max_iterations", "linesearch", "max_linesearch", "min_step", "max_step", "ftol", "wolfe", "gtol", "xtol", "orthantwise_c", "orthantwise_start", "orthantwise_end");
		}
		public static class ByReference extends lbfgs_parameter_t implements Structure.ByReference {
			
		};
		public static class ByValue extends lbfgs_parameter_t implements Structure.ByValue {
			
		};
	};
	public interface lbfgs_evaluate_t extends Callback {
		double apply(Pointer instance, DoubleByReference x, DoubleByReference g, int n, double step);
	};
	public interface lbfgs_progress_t extends Callback {
		int apply(Pointer instance, DoubleByReference x, DoubleByReference g, double fx, double xnorm, double gnorm, double step, int n, int k, int ls);
	};
	/**
	 * Start a L-BFGS optimization.<br>
	 * *  @param  n           The number of variables.<br>
	 *  @param  x           The array of variables. A client program can set<br>
	 *                      default values for the optimization and receive the<br>
	 *                      optimization result through this array. This array<br>
	 *                      must be allocated by ::lbfgs_malloc function<br>
	 *                      for libLBFGS built with SSE/SSE2 optimization routine<br>
	 *                      enabled. The library built without SSE/SSE2<br>
	 *                      optimization does not have such a requirement.<br>
	 *  @param  ptr_fx      The pointer to the variable that receives the final<br>
	 *                      value of the objective function for the variables.<br>
	 *                      This argument can be set to \c NULL if the final<br>
	 *                      value of the objective function is unnecessary.<br>
	 *  @param  proc_evaluate   The callback function to provide function and<br>
	 *                          gradient evaluations given a current values of<br>
	 *                          variables. A client program must implement a<br>
	 *                          callback function compatible with \ref<br>
	 *                          lbfgs_evaluate_t and pass the pointer to the<br>
	 *                          callback function.<br>
	 *  @param  proc_progress   The callback function to receive the progress<br>
	 *                          (the number of iterations, the current value of<br>
	 *                          the objective function) of the minimization<br>
	 *                          process. This argument can be set to \c NULL if<br>
	 *                          a progress report is unnecessary.<br>
	 *  @param  instance    A user data for the client program. The callback<br>
	 *                      functions will receive the value of this argument.<br>
	 *  @param  param       The pointer to a structure representing parameters for<br>
	 *                      L-BFGS optimization. A client program can set this<br>
	 *                      parameter to \c NULL to use the default parameters.<br>
	 *                      Call lbfgs_parameter_init() function to fill a<br>
	 *                      structure with the default values.<br>
	 *  @retval int         The status code. This function returns zero if the<br>
	 *                      minimization process terminates without an error. A<br>
	 *                      non-zero value indicates an error.<br>
	 * Original signature : <code>int lbfgs(int, lbfgsfloatval_t*, lbfgsfloatval_t*, lbfgs_evaluate_t, lbfgs_progress_t, void*, lbfgs_parameter_t*)</code><br>
	 * <i>native declaration : line 478</i><br>
	 * @deprecated use the safer methods {@link #lbfgs(int, java.nio.DoubleBuffer, java.nio.DoubleBuffer, lbfgs.LbfgsLibrary.lbfgs_evaluate_t, lbfgs.LbfgsLibrary.lbfgs_progress_t, com.sun.jna.Pointer, lbfgs.LbfgsLibrary.lbfgs_parameter_t)} and {@link #lbfgs(int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference, lbfgs.LbfgsLibrary.lbfgs_evaluate_t, lbfgs.LbfgsLibrary.lbfgs_progress_t, com.sun.jna.Pointer, lbfgs.LbfgsLibrary.lbfgs_parameter_t)} instead
	 */
	@Deprecated 
	int lbfgs(int n, DoubleByReference x, DoubleByReference ptr_fx, LbfgsLibrary.lbfgs_evaluate_t proc_evaluate, LbfgsLibrary.lbfgs_progress_t proc_progress, Pointer instance, LbfgsLibrary.lbfgs_parameter_t param);
	/**
	 * Start a L-BFGS optimization.<br>
	 * *  @param  n           The number of variables.<br>
	 *  @param  x           The array of variables. A client program can set<br>
	 *                      default values for the optimization and receive the<br>
	 *                      optimization result through this array. This array<br>
	 *                      must be allocated by ::lbfgs_malloc function<br>
	 *                      for libLBFGS built with SSE/SSE2 optimization routine<br>
	 *                      enabled. The library built without SSE/SSE2<br>
	 *                      optimization does not have such a requirement.<br>
	 *  @param  ptr_fx      The pointer to the variable that receives the final<br>
	 *                      value of the objective function for the variables.<br>
	 *                      This argument can be set to \c NULL if the final<br>
	 *                      value of the objective function is unnecessary.<br>
	 *  @param  proc_evaluate   The callback function to provide function and<br>
	 *                          gradient evaluations given a current values of<br>
	 *                          variables. A client program must implement a<br>
	 *                          callback function compatible with \ref<br>
	 *                          lbfgs_evaluate_t and pass the pointer to the<br>
	 *                          callback function.<br>
	 *  @param  proc_progress   The callback function to receive the progress<br>
	 *                          (the number of iterations, the current value of<br>
	 *                          the objective function) of the minimization<br>
	 *                          process. This argument can be set to \c NULL if<br>
	 *                          a progress report is unnecessary.<br>
	 *  @param  instance    A user data for the client program. The callback<br>
	 *                      functions will receive the value of this argument.<br>
	 *  @param  param       The pointer to a structure representing parameters for<br>
	 *                      L-BFGS optimization. A client program can set this<br>
	 *                      parameter to \c NULL to use the default parameters.<br>
	 *                      Call lbfgs_parameter_init() function to fill a<br>
	 *                      structure with the default values.<br>
	 *  @retval int         The status code. This function returns zero if the<br>
	 *                      minimization process terminates without an error. A<br>
	 *                      non-zero value indicates an error.<br>
	 * Original signature : <code>int lbfgs(int, lbfgsfloatval_t*, lbfgsfloatval_t*, lbfgs_evaluate_t, lbfgs_progress_t, void*, lbfgs_parameter_t*)</code><br>
	 * <i>native declaration : line 478</i>
	 */
	int lbfgs(int n, DoubleBuffer x, DoubleBuffer ptr_fx, LbfgsLibrary.lbfgs_evaluate_t proc_evaluate, LbfgsLibrary.lbfgs_progress_t proc_progress, Pointer instance, LbfgsLibrary.lbfgs_parameter_t param);
	/**
	 * Initialize L-BFGS parameters to the default values.<br>
	 * *  Call this function to fill a parameter structure with the default values<br>
	 *  and overwrite parameter values if necessary.<br>
	 * *  @param  param       The pointer to the parameter structure.<br>
	 * Original signature : <code>void lbfgs_parameter_init(lbfgs_parameter_t*)</code><br>
	 * <i>native declaration : line 496</i>
	 */
	void lbfgs_parameter_init(LbfgsLibrary.lbfgs_parameter_t param);
	/**
	 * Allocate an array for variables.<br>
	 * *  This function allocates an array of variables for the convenience of<br>
	 *  ::lbfgs function; the function has a requreiemt for a variable array<br>
	 *  when libLBFGS is built with SSE/SSE2 optimization routines. A user does<br>
	 *  not have to use this function for libLBFGS built without SSE/SSE2<br>
	 *  optimization.<br>
	 *  <br>
	 *  @param  n           The number of variables.<br>
	 * Original signature : <code>lbfgsfloatval_t* lbfgs_malloc(int)</code><br>
	 * <i>native declaration : line 509</i>
	 */
	DoubleByReference lbfgs_malloc(int n);
	/**
	 * Free an array of variables.<br>
	 *  <br>
	 *  @param  x           The array of variables allocated by ::lbfgs_malloc<br>
	 *                      function.<br>
	 * Original signature : <code>void lbfgs_free(lbfgsfloatval_t*)</code><br>
	 * <i>native declaration : line 517</i><br>
	 * @deprecated use the safer methods {@link #lbfgs_free(java.nio.DoubleBuffer)} and {@link #lbfgs_free(com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	void lbfgs_free(DoubleByReference x);
	/**
	 * Free an array of variables.<br>
	 *  <br>
	 *  @param  x           The array of variables allocated by ::lbfgs_malloc<br>
	 *                      function.<br>
	 * Original signature : <code>void lbfgs_free(lbfgsfloatval_t*)</code><br>
	 * <i>native declaration : line 517</i>
	 */
	void lbfgs_free(DoubleBuffer x);
}
