package lbfgs;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.Structure;
import com.sun.jna.ptr.DoubleByReference;
import java.nio.DoubleBuffer;
import java.util.Arrays;
import java.util.List;
/**
 * JNA Wrapper for library <b>lbfgs</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface LbfgsLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "lbfgs";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(LbfgsLibrary.JNA_LIBRARY_NAME);
	public static final LbfgsLibrary INSTANCE = (LbfgsLibrary)Native.loadLibrary(LbfgsLibrary.JNA_LIBRARY_NAME, LbfgsLibrary.class);
	public static final int LBFGS_SUCCESS = 0;
	public static final int LBFGS_CONVERGENCE = 0;
	public static final int LBFGS_STOP = 1;
	public static final int LBFGS_ALREADY_MINIMIZED = 2;
	public static final int LBFGSERR_UNKNOWNERROR = -1024;
	public static final int LBFGSERR_LOGICERROR = -1023;
	public static final int LBFGSERR_OUTOFMEMORY = -1022;
	public static final int LBFGSERR_CANCELED = -1021;
	public static final int LBFGSERR_INVALID_N = -1020;
	public static final int LBFGSERR_INVALID_N_SSE = -1019;
	public static final int LBFGSERR_INVALID_X_SSE = -1018;
	public static final int LBFGSERR_INVALID_EPSILON = -1017;
	public static final int LBFGSERR_INVALID_TESTPERIOD = -1016;
	public static final int LBFGSERR_INVALID_DELTA = -1015;
	public static final int LBFGSERR_INVALID_LINESEARCH = -1014;
	public static final int LBFGSERR_INVALID_MINSTEP = -1013;
	public static final int LBFGSERR_INVALID_MAXSTEP = -1012;
	public static final int LBFGSERR_INVALID_FTOL = -1011;
	public static final int LBFGSERR_INVALID_WOLFE = -1010;
	public static final int LBFGSERR_INVALID_GTOL = -1009;
	public static final int LBFGSERR_INVALID_XTOL = -1008;
	public static final int LBFGSERR_INVALID_MAXLINESEARCH = -1007;
	public static final int LBFGSERR_INVALID_ORTHANTWISE = -1006;
	public static final int LBFGSERR_INVALID_ORTHANTWISE_START = -1005;
	public static final int LBFGSERR_INVALID_ORTHANTWISE_END = -1004;
	public static final int LBFGSERR_OUTOFINTERVAL = -1003;
	public static final int LBFGSERR_INCORRECT_TMINMAX = -1002;
	public static final int LBFGSERR_ROUNDING_ERROR = -1001;
	public static final int LBFGSERR_MINIMUMSTEP = -1000;
	public static final int LBFGSERR_MAXIMUMSTEP = -999;
	public static final int LBFGSERR_MAXIMUMLINESEARCH = -998;
	public static final int LBFGSERR_MAXIMUMITERATION = -997;
	public static final int LBFGSERR_WIDTHTOOSMALL = -996;
	public static final int LBFGSERR_INVALIDPARAMETERS = -995;
	public static final int LBFGSERR_INCREASEGRADIENT = -994;
	public static final int LBFGS_LINESEARCH_DEFAULT = 0;
	public static final int LBFGS_LINESEARCH_MORETHUENTE = 0;
	public static final int LBFGS_LINESEARCH_BACKTRACKING_ARMIJO = 1;
	public static final int LBFGS_LINESEARCH_BACKTRACKING = 2;
	public static final int LBFGS_LINESEARCH_BACKTRACKING_WOLFE = 2;
	public static final int LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE = 3;
	public static final int LBFGS_FLOAT = (int)64;
	public static final int LBFGS_IEEE_FLOAT = (int)1;
	public static class lbfgs_parameter_t extends Structure {
		public int m;
		/** C type : lbfgsfloatval_t */
		public double epsilon;
		public int past;
		/** C type : lbfgsfloatval_t */
		public double delta;
		public int max_iterations;
		public int linesearch;
		public int max_linesearch;
		/** C type : lbfgsfloatval_t */
		public double min_step;
		/** C type : lbfgsfloatval_t */
		public double max_step;
		/** C type : lbfgsfloatval_t */
		public double ftol;
		/** C type : lbfgsfloatval_t */
		public double wolfe;
		/** C type : lbfgsfloatval_t */
		public double gtol;
		/** C type : lbfgsfloatval_t */
		public double xtol;
		/** C type : lbfgsfloatval_t */
		public double orthantwise_c;
		public int orthantwise_start;
		public int orthantwise_end;
		public lbfgs_parameter_t() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("m", "epsilon", "past", "delta", "max_iterations", "linesearch", "max_linesearch", "min_step", "max_step", "ftol", "wolfe", "gtol", "xtol", "orthantwise_c", "orthantwise_start", "orthantwise_end");
		}
		public lbfgs_parameter_t(Pointer peer) {
			super(peer);
		}
		public static class ByReference extends lbfgs_parameter_t implements Structure.ByReference {
			
		};
		public static class ByValue extends lbfgs_parameter_t implements Structure.ByValue {
			
		};
	};
	public interface lbfgs_evaluate_t extends Callback {
		double apply(Pointer instance, DoubleByReference x, DoubleByReference g, int n, double step);
	};
	public interface lbfgs_progress_t extends Callback {
		int apply(Pointer instance, DoubleByReference x, DoubleByReference g, double fx, double xnorm, double gnorm, double step, int n, int k, int ls);
	};
	/**
	 * Start a L-BFGS optimization.<br>
	 *  @param  n           The number of variables.<br>
	 *  @param  x           The array of variables. A client program can set<br>
	 *                      default values for the optimization and receive the<br>
	 *                      optimization result through this array. This array<br>
	 *                      must be allocated by ::lbfgs_malloc function<br>
	 *                      for libLBFGS built with SSE/SSE2 optimization routine<br>
	 *                      enabled. The library built without SSE/SSE2<br>
	 *                      optimization does not have such a requirement.<br>
	 *  @param  ptr_fx      The pointer to the variable that receives the final<br>
	 *                      value of the objective function for the variables.<br>
	 *                      This argument can be set to \c NULL if the final<br>
	 *                      value of the objective function is unnecessary.<br>
	 *  @param  proc_evaluate   The callback function to provide function and<br>
	 *                          gradient evaluations given a current values of<br>
	 *                          variables. A client program must implement a<br>
	 *                          callback function compatible with \ref<br>
	 *                          lbfgs_evaluate_t and pass the pointer to the<br>
	 *                          callback function.<br>
	 *  @param  proc_progress   The callback function to receive the progress<br>
	 *                          (the number of iterations, the current value of<br>
	 *                          the objective function) of the minimization<br>
	 *                          process. This argument can be set to \c NULL if<br>
	 *                          a progress report is unnecessary.<br>
	 *  @param  instance    A user data for the client program. The callback<br>
	 *                      functions will receive the value of this argument.<br>
	 *  @param  param       The pointer to a structure representing parameters for<br>
	 *                      L-BFGS optimization. A client program can set this<br>
	 *                      parameter to \c NULL to use the default parameters.<br>
	 *                      Call lbfgs_parameter_init() function to fill a<br>
	 *                      structure with the default values.<br>
	 *  @retval int         The status code. This function returns zero if the<br>
	 *                      minimization process terminates without an error. A<br>
	 *                      non-zero value indicates an error.<br>
	 * Original signature : <code>int lbfgs(int, lbfgsfloatval_t*, lbfgsfloatval_t*, lbfgs_evaluate_t, lbfgs_progress_t, void*, lbfgs_parameter_t*)</code><br>
	 * <i>native declaration : line 478</i><br>
	 * @deprecated use the safer methods {@link #lbfgs(int, java.nio.DoubleBuffer, java.nio.DoubleBuffer, lbfgs.LbfgsLibrary.lbfgs_evaluate_t, lbfgs.LbfgsLibrary.lbfgs_progress_t, com.sun.jna.Pointer, lbfgs.LbfgsLibrary.lbfgs_parameter_t)} and {@link #lbfgs(int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference, lbfgs.LbfgsLibrary.lbfgs_evaluate_t, lbfgs.LbfgsLibrary.lbfgs_progress_t, com.sun.jna.Pointer, lbfgs.LbfgsLibrary.lbfgs_parameter_t)} instead
	 */
	@Deprecated 
	int lbfgs(int n, DoubleByReference x, DoubleByReference ptr_fx, LbfgsLibrary.lbfgs_evaluate_t proc_evaluate, LbfgsLibrary.lbfgs_progress_t proc_progress, Pointer instance, LbfgsLibrary.lbfgs_parameter_t param);
	/**
	 * Start a L-BFGS optimization.<br>
	 *  @param  n           The number of variables.<br>
	 *  @param  x           The array of variables. A client program can set<br>
	 *                      default values for the optimization and receive the<br>
	 *                      optimization result through this array. This array<br>
	 *                      must be allocated by ::lbfgs_malloc function<br>
	 *                      for libLBFGS built with SSE/SSE2 optimization routine<br>
	 *                      enabled. The library built without SSE/SSE2<br>
	 *                      optimization does not have such a requirement.<br>
	 *  @param  ptr_fx      The pointer to the variable that receives the final<br>
	 *                      value of the objective function for the variables.<br>
	 *                      This argument can be set to \c NULL if the final<br>
	 *                      value of the objective function is unnecessary.<br>
	 *  @param  proc_evaluate   The callback function to provide function and<br>
	 *                          gradient evaluations given a current values of<br>
	 *                          variables. A client program must implement a<br>
	 *                          callback function compatible with \ref<br>
	 *                          lbfgs_evaluate_t and pass the pointer to the<br>
	 *                          callback function.<br>
	 *  @param  proc_progress   The callback function to receive the progress<br>
	 *                          (the number of iterations, the current value of<br>
	 *                          the objective function) of the minimization<br>
	 *                          process. This argument can be set to \c NULL if<br>
	 *                          a progress report is unnecessary.<br>
	 *  @param  instance    A user data for the client program. The callback<br>
	 *                      functions will receive the value of this argument.<br>
	 *  @param  param       The pointer to a structure representing parameters for<br>
	 *                      L-BFGS optimization. A client program can set this<br>
	 *                      parameter to \c NULL to use the default parameters.<br>
	 *                      Call lbfgs_parameter_init() function to fill a<br>
	 *                      structure with the default values.<br>
	 *  @retval int         The status code. This function returns zero if the<br>
	 *                      minimization process terminates without an error. A<br>
	 *                      non-zero value indicates an error.<br>
	 * Original signature : <code>int lbfgs(int, lbfgsfloatval_t*, lbfgsfloatval_t*, lbfgs_evaluate_t, lbfgs_progress_t, void*, lbfgs_parameter_t*)</code><br>
	 * <i>native declaration : line 478</i>
	 */
	int lbfgs(int n, DoubleBuffer x, DoubleBuffer ptr_fx, LbfgsLibrary.lbfgs_evaluate_t proc_evaluate, LbfgsLibrary.lbfgs_progress_t proc_progress, Pointer instance, LbfgsLibrary.lbfgs_parameter_t param);
	/**
	 * Initialize L-BFGS parameters to the default values.<br>
	 *  Call this function to fill a parameter structure with the default values<br>
	 *  and overwrite parameter values if necessary.<br>
	 *  @param  param       The pointer to the parameter structure.<br>
	 * Original signature : <code>void lbfgs_parameter_init(lbfgs_parameter_t*)</code><br>
	 * <i>native declaration : line 496</i>
	 */
	void lbfgs_parameter_init(LbfgsLibrary.lbfgs_parameter_t param);
	/**
	 * Allocate an array for variables.<br>
	 *  This function allocates an array of variables for the convenience of<br>
	 *  ::lbfgs function; the function has a requreiemt for a variable array<br>
	 *  when libLBFGS is built with SSE/SSE2 optimization routines. A user does<br>
	 *  not have to use this function for libLBFGS built without SSE/SSE2<br>
	 *  optimization.<br>
	 *  <br>
	 *  @param  n           The number of variables.<br>
	 * Original signature : <code>lbfgsfloatval_t* lbfgs_malloc(int)</code><br>
	 * <i>native declaration : line 509</i>
	 */
	DoubleByReference lbfgs_malloc(int n);
	/**
	 * Free an array of variables.<br>
	 *  <br>
	 *  @param  x           The array of variables allocated by ::lbfgs_malloc<br>
	 *                      function.<br>
	 * Original signature : <code>void lbfgs_free(lbfgsfloatval_t*)</code><br>
	 * <i>native declaration : line 517</i><br>
	 * @deprecated use the safer methods {@link #lbfgs_free(java.nio.DoubleBuffer)} and {@link #lbfgs_free(com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	void lbfgs_free(DoubleByReference x);
	/**
	 * Free an array of variables.<br>
	 *  <br>
	 *  @param  x           The array of variables allocated by ::lbfgs_malloc<br>
	 *                      function.<br>
	 * Original signature : <code>void lbfgs_free(lbfgsfloatval_t*)</code><br>
	 * <i>native declaration : line 517</i>
	 */
	void lbfgs_free(DoubleBuffer x);
}
